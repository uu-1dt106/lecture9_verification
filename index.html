<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Lecture 9</title>

		<link rel="shortcut icon" type="image/x-icon" href="uu_logo/UU_logo_color-cropped.ico">

		<link rel="stylesheet" href="reveal.js/dist/reset.css">
		<link rel="stylesheet" href="reveal.js/dist/reveal.css">
		<link rel="stylesheet" href="reveal.js/dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="atomic-one-dark.css">

		<!-- Custom css -->
		<link rel="stylesheet" href="style.css">
	</head>
	<body>
		<img class="logo" src="uu_logo/UU_logo_vit-cropped.svg">
		<div class="reveal">
			<div class="slides">

<!-- BEGIN SLIDES -->
<section data-background-image="images/background.jpg" data-background-opacity="0.2">
	<h1>Lecture 9</h1>
	<p>Nikolaus Huber</p>
</section>

<section data-background-image="images/bug.jpg" data-background-opacity="0.2">
	<h1>Verification</h1>
</section>

<section>
	<h3>Outline</h3>
	<ul>
		<li>Background</li>
		<li>Categories of testing</li>
		<li>Unit Testing</li>
		<li>Coverage</li>
		<li>System-level testing</li>
	</ul>
</section>

<section>
	<h3>Background</h3>
	<ul>
		<li><emph>Testing</emph> as <emph>dynamic verification</emph></li>
		<ul>
			<li>Trying out the program on different inputs</li>
			<li>Actually running the program</li>
		</ul>
		<li><emph>Static verfication</emph></li>
		<ul>
			<li>Analyzed program is not run</li>
			<li>Reason on <emph>mathemtical model</emph> of our program (states)</li>
		</ul>
		<li>There are also mixed approaches</li>
		<ul>
			<li>Automatic test generation from code structure</li>
			<li>Observers</li>
		</ul>
	</ul>
</section>

<section>
	<section>
		<div style="display: flex; align-items: center;">
			<img class="r-stretch" src="images/vv0.drawio.svg">
		</div>
	</section>
	<section>
		<div style="display: flex; align-items: center;">
			<img class="r-stretch" src="images/vv1.drawio.svg">
		</div>
	</section>
	<section>
		<div style="display: flex; align-items: center;">
			<img class="r-stretch" src="images/vv2.drawio.svg">
		</div>
	</section>
	<section>
		<div style="display: flex; align-items: center;">
			<img class="r-stretch" src="images/vv3.drawio.svg">
		</div>
	</section>
	<section>
		<div style="display: flex; align-items: center;">
			<img class="r-stretch" src="images/vv4.drawio.svg">
		</div>
	</section>
	<section>
		<div style="display: flex; align-items: center;">
			<img class="r-stretch" src="images/vv5.drawio.svg">
		</div>
	</section>
</section>

<section>
	<h3>What is <emph>correct</emph>?</h3>
	<ul>
		<li>Intuitively, a <emph>mathemtical proof</emph> has been found that given properties hold</li>
		<li>All preconditions are respected</li>
		<li>All postconditions are always true</li>
		<li>Different from testing</li>
		<ul>
			<li><emph>All</emph> possible program inputs and scenarios considered</li>
			<li>However: usually assume correctness of compiler, OS, HW, ...</li>
		</ul>
	</ul>
</section>

<section>
	<h3>Verificaiton vs Bug Finding</h3>
	<ul>
		<li>Usually tools/method focus either on</li>
		<ul>
			<li>Systematically looking for bugs</li>
			<li>Verifying the absence of bugs</li>
		</ul>
		<li>First can usually not guarantee anything when no bugs are found</li>
		<li>Second usually fails when bugs are encountered</li>
		<li>Some tools/methods target both at the same time</li>
	</ul>
</section>

<section>
	<h3>Deductive Verification</h3>
	<ul>
		<li>Oldest approach to verification (going back to Turing)</li>
		<li>Requires <emph>expertise + high effort</emph></li>
		<ul>
			<li>Usually need to annotate programs (invariants, ...)</li>
			<li>Development philosophy ("Formal methods")</li>
		</ul>
		<li>Success stories:</li>
		<ul>
			<li>L4 kernel</li>
			<li>Paris Métro 14 (driverless)</li>
		</ul>
	</ul>
</section>

<section>
	<h3>Abstract interpretation</h3>
	<ul>
		<li>Techniques based on fixed-point computation</li>
		<li>Good for "weaker" properties</li>
		<ul>
			<li>Absence of arithmetic overflows</li>
			<li>Absence of runtime exceptions</li>
		</ul>
		<li>Automatic, scalable, widely used by compilers</li>
		<li>Success stories</li>
		<ul>
			<li>Astrée could verify primary flight control system or Airbus A340, A380</li>
		</ul>
	</ul>
</section>

<section>
	<h3>Model Checking</h3>
	<ul>
		<li>Techniques based on (systematic) state-space exploration</li>
		<li>Many different flavours</li>
		<li>Success stories</li>
		<ul>
			<li>Hardware verification</li>
			<li>UPPAAL</li>
		</ul>
	</ul>
</section>

<section>
	<h3>Heuristic bug finders</h3>
	<ul>
		<li>Usually based on a combination of mentioned methods</li>
		<li>Mainly focussing on <emph>implicit</emph> specifications</li>
		<li>Sometimes face problems only reporting <emph>genuine</emph> bugs</li>
		<li>Related to <emph>fuzzing</emph></li>
	</ul>
</section>

<section>
	<h3>Transition systems</h3>
	<ul>
		<li>A way of capturing the program states</li>
		<li>Mathemtically a tuple $(S, I, \rightarrow)$</li>
		<ul>
			<li>State space $S$</li>
			<li>Initial states $I \subseteq S$</li>
			<li>Transitions $\rightarrow \subseteq S \times S$</li>
		</ul>
		<li>Program as transition system</li>
		<ul>
			<li>$S = \text{ControlLocations} \times \text{VariableValuations}$</li>
			<li>$I = \{\text{InitialControlState}\} \times \{\text{InitialValues}\}$</li>
			<li>$\rightarrow = ...$</li>
		</ul>
	</ul>
</section>

<section>
	<h3>Safety for transition system</h3>
	<ul>
		<li>Identify set $\text{Err} \subseteq S$ of <emph>error states</emph></li>
		<li>System $(S, I, \rightarrow)$ is <emph>safe</emph> if there is no path 
			$s_0 \rightarrow s_1 \rightarrow ... \rightarrow s_n$ with $s_0 \in I$ and $s_n \in \text{Err}$</li>
		<li>Safety of program = <emph>unreachability</emph> in graph $(S, \rightarrow)$</li>
		<li>If no error state can be reached for any possible input, the program is safe</li>
	</ul>
</section>

<section>
	<h3>Example</h3>
	<pre class="C"><code data-trim data-noescape data-line-numbers="">
		bool a, b;
		while(!a || !b) {
			if (a) 
				b = true; 
			a = !a; 
		}
		assert(b); 
	</code></pre>
</section>

<section data-background-color="white">
	<img class="r-stretch" src="images/transition_tree.drawio.svg">
</section>

<section>
	<h3>Explicit-state model checking</h3>
	<ul>
		<li>Explicitly construct graph $(S, I, \rightarrow)$</li>
		<li>Check reachability of error states</li>
		<li>Example tools: <emph>Spin</emph>, <emph>Java Path Finder</emph></li>
		<li>Problem: <emph>state-space explosion</emph></li>
		<ul>
			<li>E.g., program with ten 32-bit integers has $\geq 2^{320}$ states</li>
		</ul>
	</ul>
</section>

<section>
	<h3>Possible solutions</h3>
	<ul>
		<li>Symbolic model checking</li>
		<ul>
			<li>Represent graph $(S, I, \rightarrow)$ symbolically (usually using <emph>Binary Decision Diagrams (BDDs)</emph></li>
			<li>Check for reachability of error states using fixed-point computations</li>
		</ul>
		<li>Bounded model checking</li>
		<ul>
			<li>Only analyse program up to some depth</li>
			<li>Good at finding bugs, not unreachability</li>
			<li>Today one of the most successful techniques</li>
		</ul>
		<li>Abstraction-based Model Checking</li>
		<ul>
			<li>Analyse a simplified <emph>abstraction</emph> of the transition system</li>
			<li>Refine if the abstraction is too coarse</li>
			<li>Particularly successful for software verification</li>
		</ul>
	</ul>
</section>

<section>
	<h1>Deductive Verification</h1>
</section>

<section>
	<h3>Recap contracts</h3>
	<ul>
		<li>Contracts define <emph>pre</emph>- and <emph>postconditions</emph></li>
		<li>For function contracts:</li>
		<ul>
			<li>Precondition must be upheld by the caller of the function</li>
			<li>Postcondition must be guaranteed by the function</li>
		</ul>
		<li>Contracts can also be put on individual statements</li>
		<ul>
			<li>If precondition holds before executing statement $s$, then the postcondition must 
				hold after execution of $s$ has finished
			</li>
		</ul>
		<li>How can we apply this to C programs?</li>
	</ul>
</section>

<section>
	<h3>Background</h3>
	<ul>
		<li>At each position (state) in a program we have a set of properties that are true</li>
		<li>With each statement that we execute these properties change</li>
		<li>Mathematical basis: <emph>Hoare logic</emph></li>
		<ul>
			<li><i>An Axiomatic Basis for Computer Programming</i> (Hoare, 1969)</li>
			<li>Describe a computation step as a <emph>Hoare triple</emph> $\{P\}\; C \:\{Q\}$</li>
			<li>Whenever property $P$ holds, then after executing $C$ (if $C$ terminates), $Q$ will hold</li>
			<li>Example: $\{\Phi\}\; \textbf{nop} \:\{\Phi\}$</li>
		</ul>
	</ul>
</section>

<section>
	<h3>Background</h3>
	<ul>
		<li>Hoarse logic gives us a formulism, but no algorithm</li>
		<li><emph>Weakest precondition calculus</emph></li>
		<ul>
			<li>Guarded commands, non-determinancy and formal derivation of programs (Dijkstra, 1975)</li>
		</ul>
		<li>Given the postcondition $Q$ and a computatio $C$, we can mechanically derive a <emph>weakest precondition</emph> $P'$</li>
		<li>If $P \Rightarrow P'$ then we have proven the contract</li>
		<li>Example: For $\{P\}\; x := a \:\{x = 42\}$ the weakest precondition is $\{a = 42\}$</li>
	</ul>
</section>

<section>
	<h3>Example</h3>
	<pre class="C"><code data-trim data-noescape data-line-numbers="">
		/*
			PRE:  a > 0
			POST: ret > 0 
		*/
		int f(int a) {

			int x = a; 

			x = 2 * x;

			x = x + 2; 

			return x; 
		}
	</code></pre>
</section>

<section>
	<h3>Example</h3>
	<pre class="C"><code data-trim data-noescape data-line-numbers="">
		/*
			PRE:  a > 0
			POST: ret > 0 
		*/
		int f(int a) {

			int x = a; 

			x = 2 * x;

			x = x + 2; 
			/* { x > 0 } */
			return x; 
		}
	</code></pre>
</section>

<section>
	<h3>Example</h3>
	<pre class="C"><code data-trim data-noescape data-line-numbers="">
		/*
			PRE:  a > 0
			POST: ret > 0 
		*/
		int f(int a) {

			int x = a; 

			x = 2 * x;
			/* { x > -2 } */
			x = x + 2; 
			/* { x > 0 } */
			return x; 
		}
	</code></pre>
</section>

<section>
	<h3>Example</h3>
	<pre class="C"><code data-trim data-noescape data-line-numbers="">
		/*
			PRE:  a > 0
			POST: ret > 0 
		*/
		int f(int a) {

			int x = a; 
			/* { x > -1 } */
			x = 2 * x;
			/* { x > -2 } */
			x = x + 2; 
			/* { x > 0 } */
			return x; 
		}
	</code></pre>
</section>

<section>
	<h3>Example</h3>
	<pre class="C"><code data-trim data-noescape data-line-numbers="">
		/*
			PRE:  a > 0
			POST: ret > 0 
		*/
		int f(int a) {
			/* { a > -1 } */ 
			int x = a; 
			/* { x > -1 } */
			x = 2 * x;
			/* { x > -2 } */
			x = x + 2; 
			/* { x > 0 } */
			return x; 
		}
	</code></pre>
</section>

<section>
	<h3>Example</h3>
	<pre class="C"><code data-trim data-noescape data-line-numbers="">
		/*
			PRE:  a > 0
			POST: ret > 0 
		*/
		int f(int a) {
			/* { a > -1 } => is implied by PRE */
			int x = a; 
			/* { x > -1 } */
			x = 2 * x;
			/* { x > -2 } */
			x = x + 2; 
			/* { x > 0 } */
			return x; 
		}
	</code></pre>
</section>

<section>
	<h3>Inference rules</h3>
	<ul>
		<li>Composition of statements</li>
		<ul>
			<li>$\{P\}\; C_1 \;\{R\} \land \{R\} \; C_2 \;\{Q\} \Rightarrow \{P\}\:C_1; C_2\;\{Q\}$</li>
		</ul>
		<li>Assignment</li>
		<ul>
			<li>$\{Q[x \leftarrow E]\}\; x := E \; \{Q\}$</li>
		</ul>
		<li>Conditional execution</li>
		<ul>
			<li>$\{P \land B\}\; C_1\;\{Q\} \land \{P \land \lnot B\}\; C_2 \; \{Q\} \Rightarrow \{P\}\; \text{if}\; B \;\text{then}\; C_1\; \text{else}\; C_2\; \{Q\}$</li>
		</ul>
	</ul>
</section>

<section>
	<h3>Example</h3>
	<pre class="C"><code data-trim data-noescape data-line-numbers="">
		/* { x >= 0 } */
		
		if (B) 
			
			x = x - 2; 
		else 
			
			x = x - 4; 
		
		x = x / 2; 
		/* { x > 0 } */ 
	</code></pre>
</section>

<section>
	<h3>Example</h3>
	<pre class="C"><code data-trim data-noescape data-line-numbers="">
		/* { x >= 0 } */
		
		if (B) 
			
			x = x - 2; 
		else 
			
			x = x - 4; 
		/* { x * 2 > 0 } */ 
		x = x / 2; 
		/* { x > 0 } */  
	</code></pre>
</section>

<section>
	<h3>Example</h3>
	<pre class="C"><code data-trim data-noescape data-line-numbers="">
		/* { x >= 0 } */
		
		if (B) 
			
			x = x - 2; 
		else 
			/* { x * 2 + 4 > 0 /\ !B } */ 
			x = x - 4; 
		/* { x * 2 > 0 } */ 
		x = x / 2; 
		/* { x > 0 } */  
	</code></pre>
</section>

<section>
	<h3>Example</h3>
	<pre class="C"><code data-trim data-noescape data-line-numbers="">
		/* { x >= 0 } */
		
		if (B) 
			/* { x * 2 + 2 > 0 /\ B } */ 
			x = x - 2; 
		else 
			/* { x * 2 + 4 > 0 /\ !B } */ 
			x = x - 4; 
		/* { x * 2 > 0 } */ 
		x = x / 2; 
		/* { x > 0 } */   
	</code></pre>
</section>

<section>
	<h3>Example</h3>
	<pre class="C"><code data-trim data-noescape data-line-numbers="">
		/* { x >= 0 } */
		/* { x * 2 + 2 > 0 /\ x * 2 + 4 > 0 } */ 
		if (B) 
			/* { x * 2 + 2 > 0 /\ B } */ 
			x = x - 2; 
		else 
			/* { x * 2 + 4 > 0 /\ !B } */ 
			x = x - 4; 
		/* { x * 2 > 0 } */ 
		x = x / 2; 
		/* { x > 0 } */ 
	</code></pre>
</section>

<section>
	<h3>Example</h3>
	<pre class="C"><code data-trim data-noescape data-line-numbers="">
		/* { x >= 0 } */
		/* { x > -1 } */ 
		if (B) 
			/* { x * 2 + 2 > 0 /\ B } */ 
			x = x - 2; 
		else 
			/* { x * 2 + 4 > 0 /\ !B } */ 
			x = x - 4; 
		/* { x * 2 > 0 } */ 
		x = x / 2; 
		/* { x > 0 } */ 
	</code></pre>
</section>

<section>
	<h3>Example</h3>
	<pre class="C"><code data-trim data-noescape data-line-numbers="">
		/* { x >= 0 } => { x > -1 } */
		/* { x > -1 } */ 
		if (B) 
			/* { x * 2 + 2 > 0 /\ B } */ 
			x = x - 2; 
		else 
			/* { x * 2 + 4 > 0 /\ !B } */ 
			x = x - 4; 
		/* { x * 2 > 0 } */ 
		x = x / 2; 
		/* { x > 0 } */ 
	</code></pre>
</section>

<section>
	<h3>Loops</h3>
	<ul>
		<li>Loops are difficult</li>
		<li>We usually have to provide two things</li>
		<li><emph>Invariants</emph></li>
		<ul>
			<li>Properties that are true in every loop iteration</li>
		</ul>
		<li><emph>Variant</emph></li>
		<ul>
			<li>Something that changes with every loop iteration</li>
			<li>Needed for termination proof</li>
			<li>Loop variant needs to decrease monotonically</li>
		</ul>
		<li>More in Lab 4!</li>
	</ul>
</section>

<section>
	<h3>Frama-C</h3>
	<ul>
		<li><emph>Fra</emph>mework for <emph>m</emph>odular <emph>a</emph>nalysis of <emph>C</emph> code</li>
		<li>Collection of tools for working with C code in one framework</li>
		<li>Each feature is a separate plugin</li>
		<li>Rich set of included plugins:</li>
		<ul>
			<li>Code browsing (Metrics, callgraph, scope & dataflow analysis)</li>
			<li>Code transformation (sparecode removal, slicing, constant folding)</li>
			<li>Specification generation (RTE, Aorai)</li>
			<li>Verification (weakest precondition, abstract interpretation)</li>
		</ul>
		<li>A Lesson on Verification of IoT Software with Frama-C (Blanchard et al, HPCS 2019)</li>
	</ul>
</section>

<section>
	<h1>Thanks for today!</h1>
</section>

<!-- END SLIDES -->
</div>
</div>
		<script src="reveal.js/dist/reveal.js"></script>
		<script src="reveal.js/plugin/notes/notes.js"></script>
		<script src="reveal.js/plugin/markdown/markdown.js"></script>
		<script src="reveal.js/plugin/highlight/highlight.js"></script>
		<script src="reveal.js/plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				controlsTutorial: false,
				transition: 'fade', 
				slideNumber: 'c', 
				pdfSeparateFragments: false, 
				navigationMode: 'linear', 
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
